# Ch. 11 API 리팩터링

## Part. 01 질의 함수와 변경 함수 분리하기

### 배경

- 겉보기 부수효과가 없는 함수를 구분하기 위해 질의함수에는 부수효과를 없애는 것이 좋다.
  - 이를 위한 기법이다.

### 절차

1. 대상 함수를 복제하고 질의에 충실한 이름을 짓는다.
2. 새 질의 함수에 부수효과를 제거한다.
3. 정적검사를 수행한다.
4. 원래 함수를 호출하는 곳을 모두 찾아 반환값은 새 함수를 가져오게끔 하고, 그 후 원래 함수를 호출해 부수효과를 실행하게끔 한다.
5. 원래 함수에서 질의 코드를 제거한다.
6. 테스트한다.

### 예시

<details><summary>리팩터링 이전 코드</summary>
<div markdown="1">

```
const people = [
  "간달프",
  "사우론",
  "아라곤",
  "프로도",
  "샘",
  "김리",
  "레골라스",
  "오크",
];

function alertForMiscreants(people) {
  for (const p of people) {
    if (p === "사우론") {
      sendAlert();
      return "사우론";
    }
    if (p === "사루만") {
      sendAlert();
      return "사루만";
    }
    if (p === "오크") {
      sendAlert();
      return "오크";
    }
    return "";
  }
  function sendAlert() {
    console.log("악당 출현 BAAM~~");
  }
}
alertForMiscreants(people);

```

</div>
</details>

<details><summary>리팩터링 이후 코드</summary>
<div markdown="1">

```
const people = [
  "간달프",
  "사우론",
  "아라곤",
  "프로도",
  "샘",
  "김리",
  "레골라스",
  "오크",
];

// function alertForMiscreants(people) {
//   let found = false;
//   for (const p of people) {
//     if (!found) {
//       if (p === "사우론") {
//         sendAlert();
//         found = true;
//       }
//       if (p === "사루만") {
//         sendAlert();
//         found = true;
//       }
//       if (p === "오크") {
//         sendAlert();
//         found = true;
//       }
//     }
//   }
//   function sendAlert(miscreant = "") {
//     console.log(`악당(${miscreant}) 출현 BAAM~~`);
//   }
// }
// function findMiscreants(people) {
//   for (const p of people) {
//     if (p === "사우론") {
//       return "사우론";
//     }
//     if (p === "사루만") {
//       return "사루만";
//     }
//     if (p === "오크") {
//       return "오크";
//     }
//   }
//   return "";
// }
// const find = findMiscreants(people);
// alertForMiscreants(people);

const people = [
  "간달프",
  "사우론",
  "아라곤",
  "프로도",
  "샘",
  "김리",
  "레골라스",
  "오크",
];

function alertForMiscreants(people) {
  if (findMiscreants(people)) sendAlert();
}

function findMiscreants(people) {
  if (people.some((p) => isMiscreant(p))) return true;
  return false;

  function isMiscreant(p) {
    const miscreants = ["사우론", "사루만", "오크"];
    return miscreants.includes(p);
  }
}
function sendAlert() {
  console.log("악당 출현 BAAM~~");
}
alertForMiscreants(people);

```

</div>
</details>

### 느낀점

## Part. 02 함수 매개변수화하기

### 배경

- 여러 함수의 로직이 비슷하고 리터럴 값만 다르다면, 리터럴 값을 매개변수화 시켜면 된다.

### 절차

1. 비슷한 함수 중 하나를 선택한다.
2. 함수 선언 바꾸기로 리터럴들을 매개변수로 추가한다.
3. 호출하는 곳 모두에 적절한 리터럴 값을 추가한다.
4. 테스트한다.
5. 매개변수로 받은 값을 사용하도록 본문을 수정한다. 매 수정마다 테스트한다.
6. 비슷한 다른 함수를 호출하는 코드를 찾아 매개변수화된 함수를 호출하도록 하나씩 수정한다. 매 수정마다 테스트한다.

### 예시

<details><summary>리팩터링 이전 코드</summary>
<div markdown="1">

```
export function baseCharge(usage) {
  if (usage < 0) {
    return usd(0);
  }

  const amount =
    bottomBand(usage) * 0.03 + middleBand(usage) * 0.05 + topBand(usage) * 0.07;

  return usd(amount);
}

function bottomBand(usage) {
  return Math.min(usage, 100);
}

function middleBand(usage) {
  return usage > 100 ? Math.min(usage, 200) - 100 : 0;
}

function topBand(usage) {
  return usage > 200 ? usage - 200 : 0;
}

function usd(aNumber) {
  return aNumber;
}

```

</div>
</details>

<details><summary>리팩터링 이후 코드</summary>
<div markdown="1">

```
export function baseCharge(usage) {
  if (usage < 0) {
    return usd(0);
  }

  const amount =
    withinBand(usage, 0, 100) * 0.03 +
    withinBand(usage, 100, 200) * 0.05 +
    withinBand(usage, 200, usage) * 0.07;

  return usd(amount);
}

function withinBand(usage, bottom, top) {
  return usage > bottom ? Math.min(usage, top) - bottom : 0;
}

function usd(aNumber) {
  return aNumber;
}

```

</div>
</details>

### 느낀점

-

## Part. 03 플래그 인수 제거하기

### 배경

- 플래그 인수: 호출되는 함수가 실행할 로직을 호출하는 쪽에서 선택하기 위헤 전달하는 인수

  - 즉 함수의 무언가를 가리키기 위한 추가 인수

- 저자가 선호하지 않는 이유
  1. 플래그 인수로 인해 기능파악이 어렵다.
  2. 함수를 봐도 어떠한 값을 넘겨야 하는지 알 수 없다.
  3. 함수 내부를 봐야 어떠한 플래그인지 알 게 된다.
  - 이번 기법은 이렇게 위험한 플래그 인수를 제거하는 기법이다.

### 절차

1. 플래그 인수에 대응하는 값 각각을 담당할 명시적인 함수를 생성한다.
2. 원래 함수를 호출하는 코드를 찾아 방금 정의한 명시적 함수의 호출로 수정한다.

### 예시

- Regular
    <details><summary>리팩터링 이전 코드</summary>
    <div markdown="1">

  ```
  export function deliveryDate(anOrder, isRush) {
    if (isRush) {
      let deliveryTime;

      if (["MA", "CT"].includes(anOrder.deliveryState)) {
        deliveryTime = 1;
      } else if (["NY", "NH"].includes(anOrder.deliveryState)) {
        deliveryTime = 2;
      } else {
        deliveryTime = 3;
      }

      return anOrder.placedOn.plusDays(1 + deliveryTime);
    } else {
      let deliveryTime;

      if (["MA", "CT", "NY"].includes(anOrder.deliveryState)) {
        deliveryTime = 2;
      } else if (["ME", "NH"].includes(anOrder.deliveryState)) {
        deliveryTime = 3;
      } else {
        deliveryTime = 4;
      }

      return anOrder.placedOn.plusDays(2 + deliveryTime);
    }
  }

  ```

    </div>
    </details>

    <details><summary>리팩터링 이후 코드</summary>
    <div markdown="1">

  ```
  export function deliveryDate(anOrder, isRush) {
    if (isRush) {
      return rushDeliveryDate(anOrder);
    } else {
      return regularDeliveryDate(anOrder);
    }
  }

  export function rushDeliveryDate(anOrder) {
    let deliveryTime;

    if (["MA", "CT"].includes(anOrder.deliveryState)) {
      deliveryTime = 1;
    } else if (["NY", "NH"].includes(anOrder.deliveryState)) {
      deliveryTime = 2;
    } else {
      deliveryTime = 3;
    }

    return anOrder.placedOn.plusDays(1 + deliveryTime);
  }

  export function regularDeliveryDate(anOrder) {
    let deliveryTime;

    if (["MA", "CT", "NY"].includes(anOrder.deliveryState)) {
      deliveryTime = 2;
    } else if (["ME", "NH"].includes(anOrder.deliveryState)) {
      deliveryTime = 3;
    } else {
      deliveryTime = 4;
    }

    return anOrder.placedOn.plusDays(2 + deliveryTime);
  }

  ```

    </div>
    </details>

- 매개변수가 까다로운 방식으로 사용할 때
    <details><summary>리팩터링 이전 코드</summary>
    <div markdown="1">

  ```
  export function deliveryDate(anOrder, isRush) {
    let result;
    let deliveryTime;

    if (anOrder.deliveryState === "MA" || anOrder.deliveryState === "CT") {
      deliveryTime = isRush ? 1 : 2;
    } else if (anOrder.deliveryState === "NY" || anOrder.deliveryState === "NH") {
      deliveryTime = 2;

      if (anOrder.deliveryState === "NH" && !isRush) {
        deliveryTime = 3;
      }
    } else if (isRush) {
      deliveryTime = 3;
    } else if (anOrder.deliveryState === "ME") {
      deliveryTime = 3;
    } else {
      deliveryTime = 4;
    }

    result = anOrder.placedOn.plusDays(2 + deliveryTime);

    if (isRush) {
      result = result.minusDays(1);
    }
    // console.log(result);
    return result;
  }

  ```

    </div>
    </details>

    <details><summary>리팩터링 이후 코드</summary>
    <div markdown="1">

  ```
  export function deliveryDate(anOrder, isRush) {
    if (isRush) {
      return rushDeliveryDate(anOrder);
    } else {
      return regularDeliveryDate(anOrder);
    }
  }

  export function rushDeliveryDate(anOrder) {
    let isRush = true;
    let result;
    let deliveryTime;
    if (anOrder.deliveryState === "MA" || anOrder.deliveryState === "CT") {
      deliveryTime = 1;
    } else if (anOrder.deliveryState === "NY" || anOrder.deliveryState === "NH") {
      deliveryTime = 2;
    } else {
      deliveryTime = 3;
    }

    result = anOrder.placedOn.plusDays(1 + deliveryTime);

    return result;
  }

  export function regularDeliveryDate(anOrder) {
    let isRush = false;
    let result;
    let deliveryTime;

    if (anOrder.deliveryState === "MA" || anOrder.deliveryState === "CT") {
      deliveryTime = 2;
    } else if (anOrder.deliveryState === "NY") {
      deliveryTime = 2;
    } else if (anOrder.deliveryState === "NH" || anOrder.deliveryState === "ME") {
      deliveryTime = 3;
    } else {
      deliveryTime = 4;
    }

    result = anOrder.placedOn.plusDays(2 + deliveryTime);

    return result;
  }

  ```

    </div>
    </details>

### 느낀점

## Part. 04 객체 통째로 넘기기

### 배경

- 레코드(객체)의 값 여러 개를 넘기는 코드를 객체 통으로 넘기는 방식으로 교체할 수 있다.
- 장점
  - 더 많은 데이터를 넘기게 되었을 경우 매개변수 목록을 수정하지 않아도 된다.
  - 매개변수 목록이 짧아 이해하기가 편하다.
  - 레코드로 통합이 가능하다.

### 절차

1. 매개변수들을 원하는 형태로 받는 빈 함수를 만든다.
2. 새 함수의 본문에서는 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑한다.
3. 정적검사를 수행한다.
4. 모든 호출자가 새 함수를 사용하게 수정한다. 매 수정마다 테스트한다.
5. 원래 함수를 인라인한다.
6. 새 함수의 이름을 적절히 수정한다.

### 예시

<details><summary>리팩터링 이전 코드</summary>
<div markdown="1">

```
class HeatingPlan {
  constructor() {
    this._temperatureRange = { low: 18, high: 22 };
  }
  withinRange(bottom, top) {
    return (
      bottom >= this._temperatureRange.low && top <= this._temperatureRange.high
    );
  }
}

export function checkRangeOf(aRoom) {
  const aPlan = new HeatingPlan();
  const low = aRoom.daysTempRange.low;
  const high = aRoom.daysTempRange.high;
  if (!aPlan.withinRange(low, high)) {
    return "방 온도가 지정 범위를 벗어났습니다.";
  } else return "정상입니다.";
}

```

</div>
</details>

<details><summary>리팩터링 이후 코드</summary>
<div markdown="1">

```
class HeatingPlan {
  constructor() {
    this._temperatureRange = { low: 18, high: 22 };
  }
  withinRange(range) {
    return (
      range.low >= this._temperatureRange.low &&
      range.high <= this._temperatureRange.high
    );
  }
}

export function checkRangeOf(aRoom) {
  const aPlan = new HeatingPlan();
  const tempRange = aRoom.daysTempRange;
  if (!aPlan.withinRange(tempRange)) {
    return "방 온도가 지정 범위를 벗어났습니다.";
  } else return "정상입니다.";
}

```

</div>
</details>

### 느낀점
