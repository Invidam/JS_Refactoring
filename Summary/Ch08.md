# Chapter 08. 기능 이동

## Part 01. 함수 옮기기

### 배경

- 좋은 설계의 핵심은 모듈성이다.
  - 모듈성: 작은 일부만 이해해도 프로그램을 수정 가능케 해주는 능력
- 함수의 현재와 후보 컨텍스트를 비교하여 옮길지 말지를 결정한다.
  - 호출하는 함수, 호출되는 장소, 사용하는 데이터 등을 고려

### 절차

1. 선택한 함수가 현재 컨텍스트에서 사용중인 요소들을 살펴보고 같이 옮길 지 고민한다.
   - 함께 옮길 게 있다면 그 함수를 먼저 옮긴다.
     - 영향이 적은 함수부터 옮긴다.
   - 저수준 함수들은 고수준 함수에 인라인하여 옮긴다.
2. 선택한 함수가 다형 메서드인지 확인한다.
3. 선택한 함수를 타깃 컨텍스트로 복사한다. 그 후 다듬는다.
   - 이름 변경
   - 매개변수에 소스 컨텍스트 요소를 넘겨준다.
4. 정적 분석을 한다.
5. 소스 컨텍스트에서 타깃 함수를 참조하도록 변경한다.
6. 소스 함수를 타깃 함수의 위임 함수로 변경한다.
7. 테스트 한다.
8. 소스 함수를 인라인할 지 고민한다.

### 예시

- 중첩함수를 최상위로 빼기
    <details><summary>리팩터링 이전 코드</summary>
    <div markdown="1">

  ```
  function trackSummary(points) {
  const totalTime = calculateTime();
  const totalDistance = calculateDistance();
  const pace = totalTime / 60 / totalDistance;

  return {
      time: totalTime,
      distance: totalDistance,
      pace: pace, // km/h
  };

  // 총 거리 계산
  function calculateDistance() {
      let result = 0;

      for (let i = 1; i < points.length; i++) {
      result += distance(points[i - 1], points[i]);
      }
      return result;
  }

  // 두 지점의 거리 계산
  function distance(p1, p2) {
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
  }

  // 라디안 값으로 변환
  function radians(degrees) {}

  // 총 시간 계산
  function calculateTime(params) {
      return 3600; // min
  }
  }

  const points = [
  { x: 0, y: 0 },
  { x: 3, y: 4 },
  { x: 7, y: 1 },
  //   { x: 7, y: 3 },
  //   { x: 20, y: 0 },
  ];

  console.log(trackSummary(points));

  ```

    </div>
    </details>

    <details><summary>리팩터링 이후 코드</summary>
    <div markdown="1">

  ```
  function trackSummary(points) {
  const totalTime = calculateTime();

  const pace = totalTime / 60 / totalDistance(points);

  return {
      time: totalTime,
      distance: totalDistance(points),
      pace: pace, // km/h
  };

  // 총 시간 계산
  function calculateTime(params) {
      return 3600; // min
  }
  }

  const points = [
  { lat: 0, lon: 0 },
  { lat: 3, lon: 4 },
  { lat: 7, lon: 1 },
  //   { x: 7, y: 3 },
  //   { x: 20, y: 0 },
  ];

  console.log(trackSummary(points));


  // 총 거리 계산
  function totalDistance(points) {
  let result = 0;

  for (let i = 1; i < points.length; i++) {
      result += distance(points[i - 1], points[i]);
  }
  return result;
  }
  function distance(p1, p2) {
  // return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

  // 하버사인 공식은 다음 링크 참고
  // https://kayuse88.github.io/haversine/
  const EARTH_RADIUS = 3959; // mile
  const dLat = radians(p2.lat) - radians(p1.lat);
  const dLon = radians(p2.lon) - radians(p1.lon);
  const a =
      Math.pow(Math.sin(dLat / 2), 2) +
      Math.cos(radians(p2.lat)) *
      Math.cos(radians(p1.lat)) *
      Math.pow(Math.sin(dLon / 2), 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return EARTH_RADIUS * c;
  }

  // 라디안 값으로 변환
  function radians(degrees) {
  return (degrees * Math.PI) / 180;
  }

  ```

    </div>
    </details>

  - 진행과정
    1. 옮기고자하는 `calculateDistance`를 최상위로 복사한다.
       - 임시 함수 이름으로 `top_calculateDistance`으로 지어준다.
    2. `calculateDistance`가 의존하는 distance, radius도 `calculateDistance`안에 넣어 테스트한다.
    3. 문제가 없으면 `top_calculateDistance`으로 옮긴다.
    4. 테스트하여 수정한다.
    5. `calculateDistance`가 `top_calculateDistance`을 호출하도록 한다.
    6. `totalDistance` 변수를 제거하고 그 위치에 `top_calculateDistance`을 인라인한다.
       - 이름도 `top_calculateDistance`을 `totalDistance` 로 변경한다

- 다른 클래스로 옮기기
    <details><summary>리팩터링 이전 코드</summary>
    <div markdown="1">

  ```
    class Account {
    // 은행 이자 계산
    constructor(data) {
        ({
        //   overdraftCharge: this.overdraftCharge,
        daysOverdrawn: this.daysOverdrawn,
        type: this.type,
        } = data);
    }
    get bankCharge() {
        let result = 4.5;

        if (this.daysOverdrawn > 0) {
        result += this.overdraftCharge;
        }

        return result;
    }

    // 초과 인출 이자 계산
    get overdraftCharge() {
        if (this.type.isPremium) {
        const baseCharge = 10;

        if (this.daysOverdrawn <= 7) {
            return baseCharge;
        } else {
            return baseCharge + (this.daysOverdrawn - 7) * 0.85;
        }
        } else {
        return this.daysOverdrawn * 1.75;
        }
    }
    }

    const data = {
    daysOverdrawn: 3,
    type: { isPremium: false },
    };

    const account = new Account(data);
    console.log(account.overdraftCharge);

  ```

    </div>
    </details>

    <details><summary>리팩터링 이후 코드</summary>
    <div markdown="1">

  ```
    class AccountType {
    constructor(isPremium) {
        this.isPremium = isPremium;
    }
    overdraftCharge(account) {
        if (this.isPremium) {
        const baseCharge = 10;

        if (account.daysOverdrawn <= 7) {
            return baseCharge;
        } else {
            return baseCharge + (account.daysOverdrawn - 7) * 0.85;
        }
        } else {
        return account.daysOverdrawn * 1.75;
        }
    }
    }
    class Account {
    // 은행 이자 계산
    constructor(data) {
        ({
        //   overdraftCharge: this.overdraftCharge,
        daysOverdrawn: this.daysOverdrawn,
        type: this.type,
        } = data);
    }
    get bankCharge() {
        let result = 4.5;

        if (this.daysOverdrawn > 0) {
        result += this.overdraftCharge;
        }

        return result;
    }

    // 초과 인출 이자 계산
    get overdraftCharge() {
        return this.type.overdraftCharge(this);
    }
    }
    const accountType = new AccountType(false);
    const data = {
    daysOverdrawn: 3,
    type: accountType,
    };

    const account = new Account(data);
    console.log(account.bankCharge);
    // console.log(accountType.overdraftCharge(30));

  ```

    </div>
    </details>

  - 진행과정
    1. overdraftCharge 메서드가 사용하는 daysOverdrawn 은 Account 에 종속되므로 옮기지 않기로 결정한다.
    2. overdraftCharge 를 AccountType으로 복사한 후 정리한다.
    3. Account에서 호출하도록 변경한다.
    4. 인라인할 지를 결정한다.

### 느낀점
